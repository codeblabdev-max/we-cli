#!/usr/bin/env node

/**
 * /we:init - í”„ë¡œì íŠ¸ ì´ˆê¸°í™” ëª…ë ¹ì–´
 *
 * ì„œë²„ì— DB/Redis ìƒì„±, .env íŒŒì¼ ìƒì„±, MCP ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë“±ë¡
 */

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import inquirer from 'inquirer';
import { promises as fs } from 'fs';
import { join } from 'path';
import { execSync } from 'child_process';
import crypto from 'crypto';

const SERVER_HOST = '141.164.60.51';

// Generate secure random password
function generatePassword(length = 24) {
  return crypto.randomBytes(length).toString('base64').slice(0, length);
}

// Generate random port in range
function generatePort(base, offset = 0) {
  return base + offset;
}

// SSH command executor
async function sshExec(command, silent = false) {
  try {
    const result = execSync(`ssh root@${SERVER_HOST} "${command}"`, {
      encoding: 'utf-8',
      stdio: silent ? 'pipe' : 'inherit'
    });
    return result;
  } catch (error) {
    throw new Error(`SSH command failed: ${error.message}`);
  }
}

// Check if port is available
async function isPortAvailable(port) {
  try {
    const result = await sshExec(`ss -tlnp | grep :${port} || echo "available"`, true);
    return result.includes('available');
  } catch {
    return true;
  }
}

// Find next available port
async function findAvailablePort(startPort) {
  let port = startPort;
  while (!(await isPortAvailable(port))) {
    port++;
    if (port > startPort + 100) {
      throw new Error('No available ports found');
    }
  }
  return port;
}

// Create PostgreSQL container
async function createPostgres(projectName, config) {
  const { port, database, user, password } = config;
  const containerName = `${projectName}-postgres`;

  const command = `
    podman run -d \\
      --name ${containerName} \\
      -e POSTGRES_DB=${database} \\
      -e POSTGRES_USER=${user} \\
      -e POSTGRES_PASSWORD=${password} \\
      -p ${port}:5432 \\
      -v ${projectName}-pgdata:/var/lib/postgresql/data \\
      --restart always \\
      docker.io/library/postgres:16-alpine
  `;

  await sshExec(command.replace(/\n/g, ' '));
  return { containerName, port, database, user, password };
}

// Create Redis container
async function createRedis(projectName, config) {
  const { port, password } = config;
  const containerName = `${projectName}-redis`;

  const command = password
    ? `podman run -d --name ${containerName} -p ${port}:6379 --restart always docker.io/library/redis:7-alpine redis-server --requirepass "${password}"`
    : `podman run -d --name ${containerName} -p ${port}:6379 --restart always docker.io/library/redis:7-alpine`;

  await sshExec(command);
  return { containerName, port, password };
}

// Register project in MCP registry
async function registerProject(projectName, config) {
  const timestamp = new Date().toISOString();
  const registryPath = '/home/codeb/config/project-registry.json';

  const projectData = {
    name: projectName,
    template: config.projectType,
    registeredAt: timestamp,
    status: 'initialized',
    source: 'we-cli-init',
    environments: {
      staging: {
        ports: {
          app: config.ports.staging,
          postgres: config.postgres?.port,
          redis: config.redis?.port
        },
        domain: `${projectName}-staging.codeb.dev`,
        status: 'pending'
      },
      production: {
        ports: {
          app: config.ports.production,
          postgres: config.postgres?.port,
          redis: config.redis?.port
        },
        domain: `${projectName}.codeb.dev`,
        status: 'pending'
      }
    },
    services: {
      postgres: config.postgres ? {
        enabled: true,
        containerName: `${projectName}-postgres`,
        port: config.postgres.port,
        database: config.postgres.database,
        user: config.postgres.user
      } : { enabled: false },
      redis: config.redis ? {
        enabled: true,
        containerName: `${projectName}-redis`,
        port: config.redis.port
      } : { enabled: false }
    }
  };

  // Register via SSH
  const jqCommand = `
    mkdir -p /home/codeb/config && \\
    if [ ! -f ${registryPath} ]; then echo '{"projects":[],"lastUpdated":null}' > ${registryPath}; fi && \\
    jq --arg name "${projectName}" --argjson data '${JSON.stringify(projectData)}' --arg ts "${timestamp}" \\
      'if (.projects | map(select(.[0] == $name)) | length) == 0 then .projects += [[$name, $data]] else . end | .lastUpdated = $ts' \\
      ${registryPath} > ${registryPath}.tmp && mv ${registryPath}.tmp ${registryPath}
  `;

  await sshExec(jqCommand.replace(/\n/g, ' '));
}

// Generate .env.local file
async function generateEnvFile(projectName, config) {
  const lines = [
    `# ${projectName} Environment Variables`,
    `# Generated by we-cli init at ${new Date().toISOString()}`,
    '',
    '# App Configuration',
    `NODE_ENV=development`,
    `NEXT_PUBLIC_APP_NAME=${projectName}`,
    ''
  ];

  if (config.postgres) {
    lines.push('# Database');
    lines.push(`DATABASE_URL=postgresql://${config.postgres.user}:${config.postgres.password}@${SERVER_HOST}:${config.postgres.port}/${config.postgres.database}`);
    lines.push(`POSTGRES_HOST=${SERVER_HOST}`);
    lines.push(`POSTGRES_PORT=${config.postgres.port}`);
    lines.push(`POSTGRES_DB=${config.postgres.database}`);
    lines.push(`POSTGRES_USER=${config.postgres.user}`);
    lines.push(`POSTGRES_PASSWORD=${config.postgres.password}`);
    lines.push('');
  }

  if (config.redis) {
    lines.push('# Redis');
    if (config.redis.password) {
      lines.push(`REDIS_URL=redis://:${config.redis.password}@${SERVER_HOST}:${config.redis.port}`);
    } else {
      lines.push(`REDIS_URL=redis://${SERVER_HOST}:${config.redis.port}`);
    }
    lines.push(`REDIS_HOST=${SERVER_HOST}`);
    lines.push(`REDIS_PORT=${config.redis.port}`);
    if (config.redis.password) {
      lines.push(`REDIS_PASSWORD=${config.redis.password}`);
    }
    lines.push('');
  }

  lines.push('# Server');
  lines.push(`STAGING_PORT=${config.ports.staging}`);
  lines.push(`PRODUCTION_PORT=${config.ports.production}`);
  lines.push('');

  return lines.join('\n');
}

// Generate server .env file
async function generateServerEnvFile(projectName, config) {
  const lines = [
    `# ${projectName} Server Environment`,
    `NODE_ENV=production`,
  ];

  // Note: Use SERVER_HOST for external port access (Podman 3.x compatibility)
  // Container DNS names only work with Podman 4.x pod/network setup
  if (config.postgres) {
    lines.push(`DATABASE_URL=postgresql://${config.postgres.user}:${config.postgres.password}@${SERVER_HOST}:${config.postgres.port}/${config.postgres.database}`);
    lines.push(`POSTGRES_HOST=${SERVER_HOST}`);
    lines.push(`POSTGRES_PORT=${config.postgres.port}`);
  }

  if (config.redis) {
    if (config.redis.password) {
      lines.push(`REDIS_URL=redis://:${config.redis.password}@${SERVER_HOST}:${config.redis.port}`);
    } else {
      lines.push(`REDIS_URL=redis://${SERVER_HOST}:${config.redis.port}`);
    }
    lines.push(`REDIS_HOST=${SERVER_HOST}`);
    lines.push(`REDIS_PORT=${config.redis.port}`);
  }

  return lines.join('\n');
}

// Main init command
export const initCommand = new Command('init')
  .description('Initialize a new project with server infrastructure')
  .argument('[name]', 'Project name')
  .option('-t, --type <type>', 'Project type (nextjs, remix, nodejs, static)', 'nextjs')
  .option('--database', 'Include PostgreSQL database')
  .option('--redis', 'Include Redis cache')
  .option('--no-database', 'Skip PostgreSQL')
  .option('--no-redis', 'Skip Redis')
  .option('-i, --interactive', 'Interactive mode')
  .option('--staging-port <port>', 'Staging port')
  .option('--production-port <port>', 'Production port')
  .option('--dry-run', 'Show what would be created without creating')
  .action(async (name, options) => {
    const spinner = ora();

    try {
      let config = {};

      // Interactive mode or use options
      if (options.interactive || !name) {
        const answers = await inquirer.prompt([
          {
            type: 'input',
            name: 'projectName',
            message: 'Project name:',
            default: name || 'my-project',
            validate: (input) => /^[a-z0-9-]+$/.test(input) || 'Only lowercase letters, numbers, and hyphens allowed'
          },
          {
            type: 'list',
            name: 'projectType',
            message: 'Project type:',
            choices: ['nextjs', 'remix', 'nodejs', 'static'],
            default: 'nextjs'
          },
          {
            type: 'confirm',
            name: 'useDatabase',
            message: 'Include PostgreSQL database?',
            default: true
          },
          {
            type: 'confirm',
            name: 'useRedis',
            message: 'Include Redis cache?',
            default: false
          }
        ]);

        config = {
          projectName: answers.projectName,
          projectType: answers.projectType,
          useDatabase: answers.useDatabase,
          useRedis: answers.useRedis
        };
      } else {
        config = {
          projectName: name,
          projectType: options.type,
          useDatabase: options.database !== false,
          useRedis: options.redis === true
        };
      }

      console.log(chalk.cyan(`\nðŸš€ Initializing project: ${config.projectName}\n`));

      // Check SSH connection
      spinner.start('Checking server connection...');
      try {
        await sshExec('echo "connected"', true);
        spinner.succeed('Server connection OK');
      } catch {
        spinner.fail('Cannot connect to server');
        console.log(chalk.yellow('\nTip: Run /we:ssh setup first'));
        process.exit(1);
      }

      // Find available ports
      spinner.start('Finding available ports...');
      const basePort = 3000 + Math.floor(Math.random() * 200) * 10;
      config.ports = {
        staging: options.stagingPort ? parseInt(options.stagingPort) : await findAvailablePort(basePort + 1),
        production: options.productionPort ? parseInt(options.productionPort) : await findAvailablePort(basePort)
      };
      spinner.succeed(`Ports allocated: staging=${config.ports.staging}, production=${config.ports.production}`);

      // Create PostgreSQL
      if (config.useDatabase) {
        spinner.start('Creating PostgreSQL database...');
        const pgPort = await findAvailablePort(5432);
        config.postgres = {
          port: pgPort,
          database: config.projectName.replace(/-/g, '_'),
          user: config.projectName.replace(/-/g, '_'),
          password: generatePassword()
        };

        if (!options.dryRun) {
          await createPostgres(config.projectName, config.postgres);
        }
        spinner.succeed(`PostgreSQL created on port ${pgPort}`);
      }

      // Create Redis
      if (config.useRedis) {
        spinner.start('Creating Redis cache...');
        const redisPort = await findAvailablePort(6379);
        config.redis = {
          port: redisPort,
          password: generatePassword(16)
        };

        if (!options.dryRun) {
          await createRedis(config.projectName, config.redis);
        }
        spinner.succeed(`Redis created on port ${redisPort}`);
      }

      // Register in MCP
      spinner.start('Registering in MCP registry...');
      if (!options.dryRun) {
        await registerProject(config.projectName, config);
      }
      spinner.succeed('Project registered in MCP');

      // Generate .env.local
      spinner.start('Generating environment files...');
      const envContent = await generateEnvFile(config.projectName, config);
      const envPath = join(process.cwd(), '.env.local');

      if (!options.dryRun) {
        await fs.writeFile(envPath, envContent);

        // Create server env file
        const serverEnvContent = await generateServerEnvFile(config.projectName, config);
        const serverEnvPath = `/etc/containers/systemd/${config.projectName}.env`;
        await sshExec(`cat > ${serverEnvPath} << 'EOF'\n${serverEnvContent}\nEOF`);
        await sshExec(`cat > ${serverEnvPath.replace('.env', '-staging.env')} << 'EOF'\n${serverEnvContent}\nEOF`);
      }
      spinner.succeed('Environment files created');

      // Summary
      console.log(chalk.green('\nâœ… Project Initialized Successfully!\n'));

      console.log(chalk.white('ðŸ“¦ Project Configuration:'));
      console.log(chalk.gray(`   Name: ${config.projectName}`));
      console.log(chalk.gray(`   Type: ${config.projectType}`));
      console.log(chalk.gray(`   Staging Port: ${config.ports.staging}`));
      console.log(chalk.gray(`   Production Port: ${config.ports.production}`));

      if (config.postgres) {
        console.log(chalk.white('\nðŸ˜ PostgreSQL:'));
        console.log(chalk.gray(`   Container: ${config.projectName}-postgres`));
        console.log(chalk.gray(`   Port: ${config.postgres.port}`));
        console.log(chalk.gray(`   Database: ${config.postgres.database}`));
        console.log(chalk.gray(`   User: ${config.postgres.user}`));
      }

      if (config.redis) {
        console.log(chalk.white('\nðŸ”´ Redis:'));
        console.log(chalk.gray(`   Container: ${config.projectName}-redis`));
        console.log(chalk.gray(`   Port: ${config.redis.port}`));
      }

      console.log(chalk.white('\nðŸ“„ Files Created:'));
      console.log(chalk.cyan(`   â€¢ .env.local (local development)`));
      console.log(chalk.cyan(`   â€¢ /etc/containers/systemd/${config.projectName}.env (server)`));

      console.log(chalk.yellow('\nðŸ“‹ Next Steps:'));
      console.log(chalk.gray('   1. Create GitHub repository'));
      console.log(chalk.gray('   2. Initialize project with your framework'));
      console.log(chalk.gray('   3. Start development with Claude Code'));
      console.log(chalk.gray('   4. Run /we:workflow init when ready to deploy'));
      console.log();

      if (options.dryRun) {
        console.log(chalk.yellow('âš ï¸  DRY RUN - No changes were made\n'));
      }

    } catch (error) {
      spinner.fail('Initialization failed');
      console.log(chalk.red(`\nâŒ Error: ${error.message}\n`));
      process.exit(1);
    }
  });

export default initCommand;

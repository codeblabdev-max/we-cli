/**
 * Workflow Command
 *
 * Generates Quadlet container files and GitHub Actions CI/CD workflows
 * Supports: new project initialization, updates, and automation
 */

import chalk from 'chalk';
import ora from 'ora';
import inquirer from 'inquirer';
import { writeFile, readFile, mkdir } from 'fs/promises';
import { join, dirname } from 'path';
import { existsSync } from 'fs';

// ============================================================================
// Quadlet Template Generator
// ============================================================================

function generateQuadletTemplate(config) {
  const {
    projectName,
    containerName,
    image,
    port,
    hostPort,
    environment = 'staging',
    envVars = {},
    volumes = [],
    dependencies = [],
    healthCheck = null,
    network = 'podman'
  } = config;

  const envLines = Object.entries(envVars)
    .map(([key, value]) => {
      // Escape special characters for systemd (! ‚Üí %%21)
      const escapedValue = value.replace(/!/g, '%%21');
      return `Environment=${key}=${escapedValue}`;
    })
    .join('\n');

  const volumeLines = volumes
    .map(v => `Volume=${v}`)
    .join('\n');

  const depServices = dependencies
    .map(d => `${d}.service`)
    .join(' ');

  let template = `# ${projectName} - Quadlet Configuration
# Generated by CodeB CLI
# Environment: ${environment}

[Unit]
Description=${projectName} Application Container
After=network-online.target${dependencies.length ? ' ' + depServices : ''}
${dependencies.length ? `Requires=${depServices}` : ''}

[Container]
Image=${image}
ContainerName=${containerName}
PublishPort=${hostPort}:${port}
${envLines}
${volumeLines}
${network !== 'podman' ? `Network=${network}` : ''}

[Service]
Restart=always
TimeoutStartSec=300
${healthCheck ? `ExecStartPost=/usr/bin/sleep 5` : ''}

[Install]
WantedBy=multi-user.target default.target
`;

  // Clean up empty lines
  template = template.replace(/\n{3,}/g, '\n\n');

  return template.trim();
}

// ============================================================================
// GitHub Actions Workflow Generator (Self-hosted Runner)
// ============================================================================

function generateSelfHostedWorkflow(config) {
  const {
    projectName,
    projectType = 'nextjs',
    nodeVersion = '20',
    ports = { staging: 3001, production: 3000 },
    domains = {},
    includeTests = true,
    includeLint = true
  } = config;

  return `# ${projectName} CI/CD Pipeline (Self-hosted Runner)
# Generated by CodeB CLI
# Architecture: Server builds directly - no ARM64/AMD64 mismatch
# Advantages: No GHCR push/pull, faster deployment, Quadlet integration

name: Deploy ${projectName}

on:
  push:
    branches: [main, develop]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  APP_NAME: ${projectName}

jobs:
  # ==========================================
  # Build & Deploy (Self-hosted Runner)
  # ==========================================
  build-deploy:
    name: Build & Deploy
    runs-on: self-hosted

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine environment
        id: env
        run: |
          if [ "\${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=\${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [ "\${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
          fi

      - name: Set deployment variables
        id: vars
        run: |
          ENV="\${{ steps.env.outputs.environment }}"
          if [ "$ENV" = "production" ]; then
            echo "container_name=\${{ env.APP_NAME }}" >> $GITHUB_OUTPUT
            echo "port=${ports.production}" >> $GITHUB_OUTPUT
            echo "image_tag=latest" >> $GITHUB_OUTPUT
          else
            echo "container_name=\${{ env.APP_NAME }}-staging" >> $GITHUB_OUTPUT
            echo "port=${ports.staging}" >> $GITHUB_OUTPUT
            echo "image_tag=staging" >> $GITHUB_OUTPUT
          fi

      - name: Build image with Podman
        run: |
          echo "Building image..."
          podman build \\
            --build-arg BUILDTIME=$(date -Iseconds) \\
            --build-arg VERSION=\${{ github.sha }} \\
            --build-arg REVISION=\${{ github.sha }} \\
            -t localhost/\${{ env.APP_NAME }}:\${{ steps.vars.outputs.image_tag }} \\
            -t localhost/\${{ env.APP_NAME }}:\${{ github.sha }} \\
            .
          echo "Build complete!"

      - name: Update Quadlet configuration
        run: |
          CONTAINER_NAME="\${{ steps.vars.outputs.container_name }}"
          PORT="\${{ steps.vars.outputs.port }}"
          IMAGE_TAG="\${{ steps.vars.outputs.image_tag }}"
          ENV="\${{ steps.env.outputs.environment }}"

          # Create/update Quadlet container file
          cat > /etc/containers/systemd/\${CONTAINER_NAME}.container << EOF
          [Unit]
          Description=${projectName} Container (\${ENV})
          After=network-online.target

          [Container]
          Image=localhost/\${{ env.APP_NAME }}:\${IMAGE_TAG}
          ContainerName=\${CONTAINER_NAME}
          PublishPort=\${PORT}:3000
          EnvironmentFile=/etc/containers/systemd/\${CONTAINER_NAME}.env

          [Service]
          Restart=always
          TimeoutStartSec=300

          [Install]
          WantedBy=multi-user.target default.target
          EOF

          echo "Quadlet config updated for \${CONTAINER_NAME}"

      - name: Deploy container
        run: |
          CONTAINER_NAME="\${{ steps.vars.outputs.container_name }}"

          echo "Deploying \${CONTAINER_NAME}..."

          # Reload systemd and restart service
          systemctl daemon-reload

          # Stop old container if exists
          podman stop \${CONTAINER_NAME} 2>/dev/null || true
          podman rm \${CONTAINER_NAME} 2>/dev/null || true

          # Reset failed state and restart
          systemctl reset-failed \${CONTAINER_NAME}.service 2>/dev/null || true
          systemctl restart \${CONTAINER_NAME}.service

          echo "Waiting for container to start..."
          sleep 15

      - name: Verify deployment
        run: |
          CONTAINER_NAME="\${{ steps.vars.outputs.container_name }}"
          PORT="\${{ steps.vars.outputs.port }}"

          # Check container is running
          if podman ps | grep -q \${CONTAINER_NAME}; then
            echo "Container \${CONTAINER_NAME} is running!"
          else
            echo "Container failed to start!"
            podman logs \${CONTAINER_NAME} 2>&1 | tail -50
            exit 1
          fi

          # Health check
          sleep 5
          response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:\${PORT}/api/health || echo "000")
          if [ "$response" = "200" ]; then
            echo "Health check passed!"
          else
            echo "Health check returned: $response"
            podman logs \${CONTAINER_NAME} 2>&1 | tail -30
          fi

      - name: Show deployment info
        if: always()
        run: |
          ENV="\${{ steps.env.outputs.environment }}"
          PORT="\${{ steps.vars.outputs.port }}"

          echo ""
          echo "=========================================="
          echo "Deployment Summary"
          echo "=========================================="
          echo "Environment: \${ENV}"
          echo "Container: \${{ steps.vars.outputs.container_name }}"
          echo "Image: localhost/\${{ env.APP_NAME }}:\${{ steps.vars.outputs.image_tag }}"
          echo "Port: \${PORT}"
          echo "Commit: \${{ github.sha }}"
          echo ""

          if [ "\${ENV}" = "production" ]; then
            echo "URL: ${domains.production || `https://${projectName}.codeb.dev`}"
          else
            echo "URL: ${domains.staging || `https://${projectName}-staging.codeb.dev`}"
          fi

      - name: Update MCP Project Registry
        if: success()
        run: |
          CONTAINER_NAME="\${{ steps.vars.outputs.container_name }}"
          PORT="\${{ steps.vars.outputs.port }}"
          ENV="\${{ steps.env.outputs.environment }}"
          PROJECT_REGISTRY="/home/codeb/config/project-registry.json"
          PORT_REGISTRY="/home/codeb/config/port-registry.json"

          # Ensure config directory exists
          mkdir -p /home/codeb/config

          # Initialize project registry if not exists
          if [ ! -f "$PROJECT_REGISTRY" ]; then
            echo '{"projects":[],"lastUpdated":null}' > "$PROJECT_REGISTRY"
          fi

          TIMESTAMP=$(date -Iseconds)
          DOMAIN="${domains.production || `${projectName}.codeb.dev`}"
          if [ "$ENV" = "staging" ]; then
            DOMAIN="${domains.staging || `${projectName}-staging.codeb.dev`}"
          fi

          # Update MCP project registry (Map format: [name, project] pairs)
          if command -v jq &> /dev/null; then
            # Check if project exists in registry
            PROJECT_EXISTS=$(jq --arg name "\${{ env.APP_NAME }}" '.projects | map(select(.[0] == $name)) | length' "$PROJECT_REGISTRY")

            if [ "$PROJECT_EXISTS" -eq "0" ]; then
              # Add new project entry
              jq --arg name "\${{ env.APP_NAME }}" \\
                 --arg env "$ENV" \\
                 --arg port "$PORT" \\
                 --arg domain "$DOMAIN" \\
                 --arg container "$CONTAINER_NAME" \\
                 --arg image "localhost/\${{ env.APP_NAME }}:\${{ steps.vars.outputs.image_tag }}" \\
                 --arg timestamp "$TIMESTAMP" \\
                 '.projects += [[$name, {
                    name: $name,
                    template: "${projectType}",
                    registeredAt: $timestamp,
                    lastDeployedAt: $timestamp,
                    status: "active",
                    source: "workflow",
                    environments: {
                      ($env): {
                        ports: { app: ($port | tonumber) },
                        domain: $domain,
                        containerName: $container,
                        imageTag: $image,
                        lastDeployedAt: $timestamp,
                        status: "running"
                      }
                    },
                    containers: [{
                      name: $container,
                      type: "app",
                      environment: $env,
                      ports: [{ host: ($port | tonumber), container: 3000 }],
                      status: "running",
                      image: $image
                    }]
                  }]] | .lastUpdated = $timestamp' \\
                 "$PROJECT_REGISTRY" > "$PROJECT_REGISTRY.tmp" && mv "$PROJECT_REGISTRY.tmp" "$PROJECT_REGISTRY"
              echo "New project registered: \${{ env.APP_NAME }}"
            else
              # Update existing project entry
              jq --arg name "\${{ env.APP_NAME }}" \\
                 --arg env "$ENV" \\
                 --arg port "$PORT" \\
                 --arg domain "$DOMAIN" \\
                 --arg container "$CONTAINER_NAME" \\
                 --arg image "localhost/\${{ env.APP_NAME }}:\${{ steps.vars.outputs.image_tag }}" \\
                 --arg timestamp "$TIMESTAMP" \\
                 '(.projects | map(select(.[0] == $name)) | .[0][1]) |= (
                    .lastDeployedAt = $timestamp |
                    .status = "active" |
                    .environments[$env] = {
                      ports: { app: ($port | tonumber) },
                      domain: $domain,
                      containerName: $container,
                      imageTag: $image,
                      lastDeployedAt: $timestamp,
                      status: "running"
                    }
                  ) | .lastUpdated = $timestamp' \\
                 "$PROJECT_REGISTRY" > "$PROJECT_REGISTRY.tmp" && mv "$PROJECT_REGISTRY.tmp" "$PROJECT_REGISTRY"
              echo "Project updated: \${{ env.APP_NAME }} ($ENV)"
            fi

            # Update port registry
            if [ -f "$PORT_REGISTRY" ]; then
              jq --arg port "$PORT" \\
                 --arg name "\${{ env.APP_NAME }}" \\
                 --arg env "$ENV" \\
                 --arg timestamp "$TIMESTAMP" \\
                 'if (.usedPorts | index($port | tonumber)) then . else .usedPorts += [($port | tonumber)] end |
                  .allocations[$port] = { project: $name, environment: $env, allocatedAt: $timestamp } |
                  .lastUpdated = $timestamp' \\
                 "$PORT_REGISTRY" > "$PORT_REGISTRY.tmp" && mv "$PORT_REGISTRY.tmp" "$PORT_REGISTRY"
              echo "Port $PORT registered for \${{ env.APP_NAME }} ($ENV)"
            fi
          else
            echo "Warning: jq not installed, skipping registry update"
          fi

      - name: Cleanup old images
        if: success()
        run: |
          echo "Cleaning up old images..."
          # Keep last 3 versions
          podman images localhost/\${{ env.APP_NAME }} --format "{{.ID}} {{.CreatedAt}}" | \\
            sort -k2 -r | tail -n +4 | awk '{print $1}' | \\
            xargs -r podman rmi 2>/dev/null || true
          echo "Cleanup complete!"
`;
}

// ============================================================================
// GitHub Actions Workflow Generator (GHCR - GitHub-hosted Runner)
// ============================================================================

function generateGitHubActionsWorkflow(config) {
  const {
    projectName,
    projectType = 'nextjs',
    nodeVersion = '20',
    environments = ['staging', 'production'],
    registry = 'ghcr.io',
    serverHost = '141.164.60.51',
    serverUser = 'root',
    ports = { staging: 3001, production: 3000 },
    domains = {},
    includeTests = true,
    includeLint = true,
    useQuadlet = true
  } = config;

  const workflow = `# ${projectName} CI/CD Pipeline
# Generated by CodeB CLI
# Triggers: push to main/develop, pull requests

name: ${projectName} CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

env:
  REGISTRY: ${registry}
  IMAGE_NAME: \${{ github.repository }}

jobs:
  # ============================================
  # Build & Test
  # ============================================
  build:
    name: Build & Test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '${nodeVersion}'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci
${includeLint ? `
      - name: Run linting
        run: npm run lint
` : ''}${includeTests ? `
      - name: Run tests
        run: npm test
` : ''}
      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      # Docker Build & Push
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: \${{ env.REGISTRY }}
          username: \${{ github.actor }}
          password: \${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: \${{ steps.meta.outputs.tags }}
          labels: \${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================
  # Deploy to Staging
  # ============================================
  deploy-staging:
    name: Deploy to Staging
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/develop' || github.event_name == 'pull_request'
    environment: staging

    steps:
      - name: Deploy to Staging Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${serverHost}
          username: ${serverUser}
          key: \${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # Pull latest image
            podman pull \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:develop || \\
            podman pull \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:\${{ github.sha }}

${useQuadlet ? `            # Restart via systemd/Quadlet
            systemctl daemon-reload
            systemctl restart ${projectName}-staging.service

            # Health check
            sleep 10
            curl -sf http://localhost:${ports.staging}/api/health || exit 1` : `            # Restart container
            podman stop ${projectName}-staging || true
            podman rm ${projectName}-staging || true
            podman run -d \\
              --name ${projectName}-staging \\
              -p ${ports.staging}:3000 \\
              --restart always \\
              \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:develop

            # Health check
            sleep 10
            curl -sf http://localhost:${ports.staging}/api/health || exit 1`}

            echo "‚úÖ Staging deployment complete"

      - name: Notify Staging Deployment
        if: success()
        run: |
          echo "üöÄ Staging deployed: ${domains.staging || `staging.${projectName}.codeb.dev`}"

  # ============================================
  # Deploy to Production
  # ============================================
  deploy-production:
    name: Deploy to Production
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    environment: production

    steps:
      - name: Deploy to Production Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${serverHost}
          username: ${serverUser}
          key: \${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            # Pull latest image
            podman pull \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:latest

${useQuadlet ? `            # Restart via systemd/Quadlet
            systemctl daemon-reload
            systemctl restart ${projectName}.service

            # Health check
            sleep 10
            curl -sf http://localhost:${ports.production}/api/health || exit 1` : `            # Restart container
            podman stop ${projectName} || true
            podman rm ${projectName} || true
            podman run -d \\
              --name ${projectName} \\
              -p ${ports.production}:3000 \\
              --restart always \\
              \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:latest

            # Health check
            sleep 10
            curl -sf http://localhost:${ports.production}/api/health || exit 1`}

            echo "‚úÖ Production deployment complete"

      - name: Notify Production Deployment
        if: success()
        run: |
          echo "üéâ Production deployed: ${domains.production || `${projectName}.codeb.dev`}"

  # ============================================
  # Preview Deployment (for PRs)
  # ============================================
  deploy-preview:
    name: Deploy Preview
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    environment: preview

    steps:
      - name: Deploy Preview Environment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${serverHost}
          username: ${serverUser}
          key: \${{ secrets.SSH_PRIVATE_KEY }}
          script: |
            PR_NUMBER=\${{ github.event.pull_request.number }}
            PREVIEW_PORT=$((3100 + PR_NUMBER))

            # Pull PR image
            podman pull \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:pr-\${PR_NUMBER} || \\
            podman pull \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:\${{ github.sha }}

            # Deploy preview container
            podman stop ${projectName}-pr-\${PR_NUMBER} || true
            podman rm ${projectName}-pr-\${PR_NUMBER} || true
            podman run -d \\
              --name ${projectName}-pr-\${PR_NUMBER} \\
              -p \${PREVIEW_PORT}:3000 \\
              --restart unless-stopped \\
              \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}:\${{ github.sha }}

            echo "‚úÖ Preview deployed on port \${PREVIEW_PORT}"

      - name: Comment PR with Preview URL
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request.number;
            const previewUrl = \`https://${projectName}-pr-\${prNumber}.codeb.dev\`;

            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: \`üîç **Preview Environment Ready**\\n\\nüåê URL: \${previewUrl}\\nüì¶ Commit: \${context.sha.substring(0, 7)}\`
            });
`;

  return workflow;
}

// ============================================================================
// Dockerfile Generator
// ============================================================================

function generateDockerfile(config) {
  const { projectType = 'nextjs', nodeVersion = '20' } = config;

  if (projectType === 'nextjs') {
    return `# Next.js Production Dockerfile
# Generated by CodeB CLI
# Multi-stage build for optimized image size

FROM node:${nodeVersion}-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Next.js collects anonymous telemetry data
ENV NEXT_TELEMETRY_DISABLED 1

RUN npm run build

# Production image, copy all the files and run next
FROM base AS runner
WORKDIR /app

ENV NODE_ENV production
ENV NEXT_TELEMETRY_DISABLED 1

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public

# Set the correct permission for prerender cache
RUN mkdir .next
RUN chown nextjs:nodejs .next

# Automatically leverage output traces to reduce image size
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static

USER nextjs

EXPOSE 3000

ENV PORT 3000
ENV HOSTNAME "0.0.0.0"

CMD ["node", "server.js"]
`;
  }

  if (projectType === 'remix') {
    return `# Remix Production Dockerfile
# Generated by CodeB CLI

FROM node:${nodeVersion}-alpine AS base

FROM base AS deps
RUN apk add --no-cache libc6-compat
WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci

FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

RUN npm run build

FROM base AS runner
WORKDIR /app

ENV NODE_ENV production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 remix

COPY --from=builder --chown=remix:nodejs /app/build ./build
COPY --from=builder --chown=remix:nodejs /app/public ./public
COPY --from=builder --chown=remix:nodejs /app/package.json ./
COPY --from=builder --chown=remix:nodejs /app/node_modules ./node_modules

USER remix

EXPOSE 3000

CMD ["npm", "start"]
`;
  }

  // Default Node.js
  return `# Node.js Production Dockerfile
# Generated by CodeB CLI

FROM node:${nodeVersion}-alpine

WORKDIR /app

COPY package.json package-lock.json* ./
RUN npm ci --only=production

COPY . .

ENV NODE_ENV production

EXPOSE 3000

CMD ["node", "index.js"]
`;
}

// ============================================================================
// Main Command Handler
// ============================================================================

export async function workflow(action, target, options) {
  console.log(chalk.blue.bold(`\n‚öôÔ∏è  CodeB Workflow Generator\n`));

  switch (action) {
    case 'init':
      await initWorkflow(target, options);
      break;
    case 'quadlet':
      await generateQuadlet(target, options);
      break;
    case 'github-actions':
    case 'gh':
      await generateGitHubActions(target, options);
      break;
    case 'dockerfile':
    case 'docker':
      await generateDockerfileCommand(target, options);
      break;
    case 'update':
      await updateWorkflow(target, options);
      break;
    default:
      console.log(chalk.red(`Unknown action: ${action}`));
      console.log(chalk.gray('\nAvailable actions:'));
      console.log(chalk.gray('  init         - Initialize complete workflow (Quadlet + GitHub Actions)'));
      console.log(chalk.gray('  quadlet      - Generate Quadlet .container file'));
      console.log(chalk.gray('  github-actions - Generate GitHub Actions workflow'));
      console.log(chalk.gray('  dockerfile   - Generate optimized Dockerfile'));
      console.log(chalk.gray('  update       - Update existing workflow configurations'));
  }
}

// ============================================================================
// Action Handlers
// ============================================================================

async function initWorkflow(projectName, options) {
  const spinner = ora('Initializing workflow configuration...').start();

  try {
    // Interactive configuration if not provided via options
    let config = {};

    if (options.interactive !== false) {
      spinner.stop();

      const answers = await inquirer.prompt([
        {
          type: 'input',
          name: 'projectName',
          message: 'Project name:',
          default: projectName || 'my-project'
        },
        {
          type: 'list',
          name: 'projectType',
          message: 'Project type:',
          choices: ['nextjs', 'remix', 'nodejs', 'static'],
          default: 'nextjs'
        },
        {
          type: 'input',
          name: 'stagingPort',
          message: 'Staging port:',
          default: '3001'
        },
        {
          type: 'input',
          name: 'productionPort',
          message: 'Production port:',
          default: '3000'
        },
        {
          type: 'input',
          name: 'stagingDomain',
          message: 'Staging domain:',
          default: (answers) => `${answers.projectName}-staging.codeb.dev`
        },
        {
          type: 'input',
          name: 'productionDomain',
          message: 'Production domain:',
          default: (answers) => `${answers.projectName}.codeb.dev`
        },
        {
          type: 'confirm',
          name: 'useDatabase',
          message: 'Include PostgreSQL database?',
          default: true
        },
        {
          type: 'confirm',
          name: 'useRedis',
          message: 'Include Redis cache?',
          default: false
        },
        {
          type: 'confirm',
          name: 'includeTests',
          message: 'Include tests in CI/CD?',
          default: true
        },
        {
          type: 'confirm',
          name: 'useSelfHosted',
          message: 'Use self-hosted runner? (Recommended for ARM Mac users)',
          default: true
        }
      ]);

      config = answers;
      spinner.start('Generating workflow files...');
    } else {
      config = {
        projectName: projectName || options.name || 'my-project',
        projectType: options.type || 'nextjs',
        stagingPort: options.stagingPort || '3001',
        productionPort: options.productionPort || '3000',
        stagingDomain: options.stagingDomain,
        productionDomain: options.productionDomain,
        useDatabase: options.database,
        useRedis: options.redis,
        includeTests: options.tests !== false,
        useSelfHosted: options.selfHosted !== false  // default: true
      };
    }

    const outputDir = options.output || '.';
    const files = [];

    // 1. Generate Quadlet files
    const quadletConfig = {
      projectName: config.projectName,
      containerName: config.projectName,
      image: `localhost/${config.projectName}:latest`,
      port: 3000,
      hostPort: parseInt(config.productionPort),
      environment: 'production',
      envVars: {
        NODE_ENV: 'production',
        PORT: '3000'
      }
    };

    if (config.useDatabase) {
      quadletConfig.envVars.DATABASE_URL = `postgresql://postgres:postgres@${config.projectName}-postgres:5432/${config.projectName}?schema=public`;
      quadletConfig.dependencies = [`${config.projectName}-postgres`];
    }

    const quadletContent = generateQuadletTemplate(quadletConfig);
    const quadletPath = join(outputDir, 'quadlet', `${config.projectName}.container`);
    await mkdir(dirname(quadletPath), { recursive: true });
    await writeFile(quadletPath, quadletContent);
    files.push(quadletPath);

    // Staging Quadlet
    const stagingQuadletConfig = {
      ...quadletConfig,
      containerName: `${config.projectName}-staging`,
      hostPort: parseInt(config.stagingPort),
      environment: 'staging',
      envVars: {
        ...quadletConfig.envVars,
        NODE_ENV: 'staging'
      }
    };
    const stagingQuadletContent = generateQuadletTemplate(stagingQuadletConfig);
    const stagingQuadletPath = join(outputDir, 'quadlet', `${config.projectName}-staging.container`);
    await writeFile(stagingQuadletPath, stagingQuadletContent);
    files.push(stagingQuadletPath);

    // 2. Generate GitHub Actions workflow
    const ghConfig = {
      projectName: config.projectName,
      projectType: config.projectType,
      ports: {
        staging: parseInt(config.stagingPort),
        production: parseInt(config.productionPort)
      },
      domains: {
        staging: config.stagingDomain || `${config.projectName}-staging.codeb.dev`,
        production: config.productionDomain || `${config.projectName}.codeb.dev`
      },
      includeTests: config.includeTests,
      useQuadlet: true
    };

    // Use self-hosted or GHCR workflow based on config
    const ghWorkflow = config.useSelfHosted
      ? generateSelfHostedWorkflow(ghConfig)
      : generateGitHubActionsWorkflow(ghConfig);
    const ghPath = join(outputDir, '.github', 'workflows', 'deploy.yml');
    await mkdir(dirname(ghPath), { recursive: true });
    await writeFile(ghPath, ghWorkflow);
    files.push(ghPath);

    // 3. Generate Dockerfile
    const dockerfile = generateDockerfile({ projectType: config.projectType });
    const dockerfilePath = join(outputDir, 'Dockerfile');
    if (!existsSync(dockerfilePath)) {
      await writeFile(dockerfilePath, dockerfile);
      files.push(dockerfilePath);
    }

    // 4. Generate database Quadlet if needed
    if (config.useDatabase) {
      const dbQuadlet = generateQuadletTemplate({
        projectName: `${config.projectName}-postgres`,
        containerName: `${config.projectName}-postgres`,
        image: 'postgres:15-alpine',
        port: 5432,
        hostPort: 5432 + Math.floor(Math.random() * 100),
        envVars: {
          POSTGRES_USER: 'postgres',
          POSTGRES_PASSWORD: 'postgres',
          POSTGRES_DB: config.projectName
        },
        volumes: [`${config.projectName}-postgres-data:/var/lib/postgresql/data:Z`]
      });
      const dbPath = join(outputDir, 'quadlet', `${config.projectName}-postgres.container`);
      await writeFile(dbPath, dbQuadlet);
      files.push(dbPath);
    }

    spinner.succeed('Workflow files generated');

    console.log(chalk.green('\n‚úÖ Workflow Initialization Complete\n'));
    console.log(chalk.gray('Generated files:'));
    files.forEach(f => console.log(chalk.cyan(`  ‚Ä¢ ${f}`)));

    console.log(chalk.yellow('\nüìã Next steps:'));
    if (config.useSelfHosted) {
      console.log(chalk.gray('  1. Register self-hosted runner on the server:'));
      console.log(chalk.cyan('     gh api -X POST repos/OWNER/REPO/actions/runners/registration-token'));
      console.log(chalk.gray('  2. Create environment file on server:'));
      console.log(chalk.cyan(`     /etc/containers/systemd/${config.projectName}.env`));
      console.log(chalk.gray('  3. Push to GitHub to trigger deployment'));
      console.log(chalk.green('\n‚ú® Self-hosted runner: No GHCR, no ARM64/AMD64 issues!'));
    } else {
      console.log(chalk.gray('  1. Copy quadlet/*.container files to /etc/containers/systemd/ on server'));
      console.log(chalk.gray('  2. Run: systemctl daemon-reload'));
      console.log(chalk.gray('  3. Add SSH_PRIVATE_KEY to GitHub repository secrets'));
      console.log(chalk.gray('  4. Push to GitHub to trigger deployment'));
    }
    console.log();

  } catch (error) {
    spinner.fail('Workflow initialization failed');
    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
    process.exit(1);
  }
}

async function generateQuadlet(projectName, options) {
  const spinner = ora('Generating Quadlet configuration...').start();

  try {
    const config = {
      projectName: projectName || options.name || 'my-project',
      containerName: options.container || projectName,
      image: options.image || `localhost/${projectName}:latest`,
      port: parseInt(options.containerPort) || 3000,
      hostPort: parseInt(options.port) || 3000,
      environment: options.environment || 'production',
      envVars: options.env ? JSON.parse(options.env) : {},
      volumes: options.volumes ? options.volumes.split(',') : [],
      dependencies: options.depends ? options.depends.split(',') : []
    };

    const content = generateQuadletTemplate(config);
    const outputPath = options.output || `${config.projectName}.container`;

    await writeFile(outputPath, content);
    spinner.succeed(`Quadlet file generated: ${outputPath}`);

    console.log(chalk.green('\n‚úÖ Quadlet Configuration Generated\n'));
    console.log(chalk.gray('Install on server:'));
    console.log(chalk.cyan(`  scp ${outputPath} root@server:/etc/containers/systemd/`));
    console.log(chalk.cyan('  ssh root@server "systemctl daemon-reload && systemctl start ' + config.projectName + '.service"'));
    console.log();

  } catch (error) {
    spinner.fail('Quadlet generation failed');
    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
    process.exit(1);
  }
}

async function generateGitHubActions(projectName, options) {
  const spinner = ora('Generating GitHub Actions workflow...').start();

  try {
    const config = {
      projectName: projectName || options.name || 'my-project',
      projectType: options.type || 'nextjs',
      serverHost: options.host || '141.164.60.51',
      serverUser: options.user || 'root',
      ports: {
        staging: parseInt(options.stagingPort) || 3001,
        production: parseInt(options.productionPort) || 3000
      },
      domains: {
        staging: options.stagingDomain,
        production: options.productionDomain
      },
      includeTests: options.tests !== false,
      includeLint: options.lint !== false,
      useQuadlet: options.quadlet !== false
    };

    const content = generateGitHubActionsWorkflow(config);
    const outputDir = options.output || '.github/workflows';
    const outputPath = join(outputDir, 'deploy.yml');

    await mkdir(outputDir, { recursive: true });
    await writeFile(outputPath, content);
    spinner.succeed(`GitHub Actions workflow generated: ${outputPath}`);

    console.log(chalk.green('\n‚úÖ GitHub Actions Workflow Generated\n'));
    console.log(chalk.yellow('Required GitHub Secrets:'));
    console.log(chalk.gray('  ‚Ä¢ SSH_PRIVATE_KEY - SSH key for server access'));
    console.log();

  } catch (error) {
    spinner.fail('GitHub Actions generation failed');
    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
    process.exit(1);
  }
}

async function generateDockerfileCommand(projectName, options) {
  const spinner = ora('Generating Dockerfile...').start();

  try {
    const config = {
      projectType: options.type || 'nextjs',
      nodeVersion: options.node || '20'
    };

    const content = generateDockerfile(config);
    const outputPath = options.output || 'Dockerfile';

    if (existsSync(outputPath) && !options.force) {
      spinner.stop();
      const { overwrite } = await inquirer.prompt([{
        type: 'confirm',
        name: 'overwrite',
        message: `Dockerfile already exists. Overwrite?`,
        default: false
      }]);

      if (!overwrite) {
        console.log(chalk.gray('Operation cancelled'));
        return;
      }
      spinner.start();
    }

    await writeFile(outputPath, content);
    spinner.succeed(`Dockerfile generated: ${outputPath}`);

    console.log(chalk.green('\n‚úÖ Dockerfile Generated\n'));
    console.log(chalk.gray('Build command:'));
    console.log(chalk.cyan(`  docker build -t ${projectName || 'my-app'}:latest .`));
    console.log();

  } catch (error) {
    spinner.fail('Dockerfile generation failed');
    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
    process.exit(1);
  }
}

async function updateWorkflow(projectName, options) {
  const spinner = ora('Updating workflow configurations...').start();

  try {
    // Check for existing files
    const quadletPath = join('quadlet', `${projectName}.container`);
    const ghPath = join('.github', 'workflows', 'deploy.yml');

    const updates = [];

    if (existsSync(quadletPath)) {
      spinner.text = 'Updating Quadlet configuration...';
      // Read and update quadlet
      updates.push('Quadlet configuration');
    }

    if (existsSync(ghPath)) {
      spinner.text = 'Updating GitHub Actions workflow...';
      // Read and update workflow
      updates.push('GitHub Actions workflow');
    }

    if (updates.length === 0) {
      spinner.warn('No existing workflow files found');
      console.log(chalk.yellow('\nRun "codeb workflow init" to create new workflow files'));
      return;
    }

    spinner.succeed('Workflow configurations updated');
    console.log(chalk.green('\n‚úÖ Updated:'));
    updates.forEach(u => console.log(chalk.cyan(`  ‚Ä¢ ${u}`)));
    console.log();

  } catch (error) {
    spinner.fail('Workflow update failed');
    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
    process.exit(1);
  }
}
